/*
Задание

Найти в строке последовательность одинаковых символов максимальной длины и переписать в выходную строку в виде n1,n2c – начало и длина фрагмента и символ, например abcddddddddddddedfg -> 3,12d. Из исходной строки фрагмент удалить. Повторять этот процесс. Пока в строке есть последовательности, в конце переписать остаток в выходную строку.
*/

/*
Основные функции, которые потребуются

=============================================1. Функции комипровния======================================================

##########################################################################################################################
##########################################################################################################################

char *strcpy(char *str1, const char *str2)
Прототип: 
    string.h
Описание: 
    Функция strcpy() используется для копирования содержимого str2 в str1. Аргумент str2 должен быть указателем на строку, оканчивающуюся нулем. Функция strcpy() возвращает указатель на str1. Если строки str1 и str2 перекрываются, то поведение функции strcpy() не определено.

##########################################################################################################################
##########################################################################################################################

char *strncpy(char *dest, const char *source, size_t count)
Описание: 
    Функция strncpy() используется для копирования до count символов содержимого строки, на которую указывает source, в строку, на которую указывает dest. Аргумент source должен быть указателем на строку, оканчивающуюся нулевым символом. Функция strncpy() возвращает указа­тель на dest.

##########################################################################################################################
##########################################################################################################################

int sprintf(char *buf, const char *format, arg-list)
Прототип: 
    stdio.h
Описание: 
    Функция sprintf() идентична printf(), за исключением того, что вывод производится в массив, указанный аргументом buf.

Возвращаемая величина равна количеству символов, действительно занесенных в массив.

##########################################################################################################################
##########################################################################################################################

int snprintf(char *restrict buf, size_t num, const char *restrict format, ...);
    Функция snprintf() добавлена в версии C99.
Прототип: 
    stdio.h
Описание:
    Она идентична функции sprintf() за исключением того, что в массиве, адресуемом указателем buf, будет сохранено максимум num-1 символов. По окончании работы функции этот массив будет завершаться символом конца строки (нуль-символом). Таким образом, функция snprintf() позволяет предотвратить переполнение буфера buf.



##########################################################################################################################
##########################################################################################################################

void *memcpy(void *dest, const void *source, size_t count)
Прототип: 
    mem.h
    string.h
Описание: 
    Функция memcpy() копирует count символов из массива, на который указывает source, в массив, на который указывает dest. Если массивы перекрываются, поведение memcpy() не определено.

    ЕЕ НУЖНО ЗНАТЬ И ПОЛЬЗОВАТЬСЯ ТОЛЬКО ДЛЯ КОПИРОВАНИИ ПАМЯТИ, ДЛЯ СТРОК ИСПОЛЬЗУЕМ Ф-ИИ ОПИСАННЫЕ ВЫШЕ
    Очень удобно, если потребуется скопировать, например, структуру, чтобы не перезаполнять элементы, но об этом на следующих этапах изучения Си

##########################################################################################################################
##########################################################################################################################

==========================================2. Функции сравнения============================================================

##########################################################################################################################
##########################################################################################################################

int strncmp(const char *str1, const char *str2, size_t count)
Прототип: 
    string.h
Описание: 
    Функция strncmp() осуществляет лексикографическое сравнение не более чем count символов из двух строк, оканчивающихся нулевыми символами.
    Если строки равны возвращается 0 !!! ВАЖНО ЗАПОМНИТЬ, НА ЭТОМ МОЖНО ПОГОРЕТЬ
    Если str1 меньше, чем str2 возвращается <0
    Если str1 больше, чем str2 возвращается >0
    Есть strcmp(const char *str1, const char *str2), делает тоже самое, но ненужно указывать кол-во сравниваемых символов

##########################################################################################################################
##########################################################################################################################

char *strstr(const char *str1, const char *str2)
Прототип: 
    string.h
Описание: 
    Функция strstr() возвращает указатель на первое вхождение в строку, на которую указывает str1, строки, указанной str2 (исключая завершающий нулевой символ). Если совпадений не обна­ружено, возвращается NULL.

##########################################################################################################################
##########################################################################################################################
int memcmp(const void *buf1, const void *buf2, size_t count)

Прототип: 
    mem.h
    string.h
Описание: 
    Функция memcmp() не опре­делена стандартом ANSI С.

    Функция memcmp() сравнивает первые count символов массивов, на которые указывают buf1 и buf2. Сравнение производится лексикографически. 
    Если память одинаковая возвращается 0 !!! ВАЖНО ЗАПОМНИТЬ НА ЭТОМ МОЖНО ПОГОРЕТЬ
    Если buf1 меньше, чем buf2 возвращается <0
    Если buf1 больше, чем buf2 возвращается >0


ЕЕ НУЖНО ЗНАТЬ И ПОЛЬЗОВАТЬСЯ ТОЛЬКО ДЛЯ СРАВНЕНИИ ПАМЯТИ, ДЛЯ СТРОК ИСПОЛЬЗУЕМ Ф-ИИ ОПИСАННЫЕ ВЫШЕ
Очень удобно, если потребуется сравнить, например, структуру, чтобы не сравнивать элементы по отдельности, но об этом на следующих этапах изучения Си

##########################################################################################################################
##########################################################################################################################

============================================3. Преобразование строки в число==============================================

##########################################################################################################################
##########################################################################################################################

int atoi(const char *str)
Прототип: 
    stdlib.h
Описание: 
    Функция atoi() конвертирует строку, на которую указывает параметр str, в величину типа int. Строка должна содержать корректную запись целого числа. В противном случае возвращается 0.

    Число может завершаться любым символом, который не может входить в состав строкового представления целого числа. Сюда относятся пробелы, знаки пунктуации и другие знаки, не яв­ляющиеся цифрами. Таким образом, вызов функции atoi() для числа 123.23 возвратит целое зна­чение, а часть 0.23 будет опущена.
    Есть atol вернет число типа long
    Есть atof вернет число типа double

##########################################################################################################################
##########################################################################################################################

    #include <string.h>
    void *memset(void *buf, int ch, size_t count);
    Функция memset() копирует младший байт параметра ch в первые count символов массива, адресуемого параметром buf. Функция возвращает значение указателя buf.



/*
В строке найти последовательности цифр, каждую из них считать числом в той системе счисления,\n
которая соответствует максимальной цифре, заменить числа в строке символами с кодами, полученными\n
из этих чисел. Пример: aaa010101bbb343ccc – двоичная и пятиричная системы счисления.
*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define FIRST_ANCII_CODE 33
#define LAST_ANCII_CODE 126
#define MAX_STR_LEN 256

int definition_of_number_system(int number);
int conversion_to_decimal_number_system(int num, int *pos);

int definition_of_number_system(int num)
{
    int num_system = 0, check_num = 0;

/* Убрал проверку так как она избыточна. Мы проверяем, что number_int не 0 */

    while (num > 0)
    {
        check_num = num % 10;
        if (check_num > num_system)
            num_system = check_num;

        num /= 10;
    }
    return ++num_system;
}

int conversion_to_decimal_number_system(int num, int *pos)
{
    int pos_num = 0, ret_num = 0, num_system = 0;
    *pos = 0;

    num_system = definition_of_number_system(num);

    while (num > 0)
    {
        pos_num = num % 10;
        ret_num += pos_num * pow(num_system, *pos);
        num /= 10;
        *pos += 1;
    }
    return ret_num;
}

int main()
{
    char input_string[MAX_STR_LEN] = {0}; 
    int number_int = 0, char_code = 0, position = 0;
    char *ptr_char = input_string;

    printf("\nВ строке найти последовательности цифр, каждую из них считать числом в той системе счисления,\n"
              "которая соответствует максимальной цифре, заменить числа в строке символами с кодами, полученными\n"
              "из этих чисел. Пример: aaa010101bbb343ccc – двоичная и пятиричная системы счисления.");
    printf("\nInput string: ");
    fgets(input_string, MAX_STR_LEN, stdin); 

    printf("Result string: ");
    while(*ptr_char != 0)
    {
        number_int = atoi(ptr_char);
        if (!number_int)
        {
            printf("%c", *ptr_char);
            ptr_char++;
        }
        else
        {
            char_code = conversion_to_decimal_number_system(number_int, &position);
            ptr_char += position;

            if (FIRST_ANCII_CODE <= char_code && char_code <= LAST_ANCII_CODE)
            {
                printf("%c", char_code);
            }
        }
    }
    return 0;
}

/*
int main() {
#include <stdio.h> 
#include <string.h> 
#include <stdlib.h> 
#include <math.h> 
#define NUM 50 
 
int zamena (int x, int y){ 
    if(x / y == 0){ 
        printf("%d", x % y); 
    } 
    else { 
        zamena (x / y, y); 
        printf("%d", x % y); 
    } 
} 
 
int main() { 

    char str[NUM] = {0}, chislo[NUM] = {0}; 
    int b = 0, j = 0, n = 0, max = 0, length = 0, a = 0, i = 0; 
     
    fgets(str, NUM, stdin); 
    for(char * p = str; *p != 0; *p++){ 
        if(*p >= 48 && *p <= 57) { 
            chislo[b] = *p;
            b++; 
            if(*p - 48 > max) { 
                max = *p - 48; 
            } 
        } 
        else { 
            if(b != 0){ 
                length = strlen(chislo); 
                for(char * u = chislo; *u != 0; *u++){ 
                    a = a + (*u - 48) * pow(max, length - 1); 
                    length--; 
                } 
                zamena(a, max + 1); 
    
                
                a = max = b = 0; 
                memset(chislo, 0, sizeof(chislo));
            } 

            if(*p < 48 || *p > 57){ 
                printf("%c", *p); 
            } 
 
        } 
    } 
 
    return 0; 
}*/
